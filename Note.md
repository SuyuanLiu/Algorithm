# Note

摘抄自[这里](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode%20%E9%A2%98%E8%A7%A3.md#bfs)，给自己复习用的。

- [BFS](#BFS)
- [DFS](#DFS)
- [DP](#DP)


## Summary

- BFS:求解最短路径等**最优解**问题,只能用于求无权图的最短路径。
- 普通 DFS：主要用在  **可达性问题** ，这种问题只需要执行到特点的位置然后返回即可。
- Backtracking：主要用于求解  **排列组合**  问题。


## BFS

BFS一层一层地进行遍历，每层遍历都以上一层遍历结果作为起点，每层遍历的是一个距离能访问到的所有节点。对于先遍历的结点i与后遍历的结点j，有di<=dj，所以可以利用这个结论，求解最短路径等**最优解**问题。第一次便利到目的节点，其所经过的路径为最短路径。BFS只能用于求无权图的最短路径。

- 用队列，存储每一轮遍历得到的节点；
- 对已经遍历过的节点进行标记；

## DFS

从根节点一直遍历到最后的节点，得到一个新节点就立即遍历，然后再返回到根节点。

从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种**可达性**问题。 

- 用栈，保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点，可以使用递归栈。
- 标记，和 BFS 一样同样需要对已经遍历过的节点进行标记。

### Backtracking

Backtracking（回溯）属于 DFS。

- 普通 DFS 主要用在  **可达性问题** ，这种问题只需要执行到特点的位置然后返回即可。
- 而 Backtracking 主要用于求解  **排列组合**  问题，例如有 { 'a','b','c' } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。

因为 Backtracking 不是立即就返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：

- 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
- 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。
 
 
## DP 