前序遍历
- 非递归方法（推荐）
- 递归：遍历, traverse
- 递归：分治法, divide conquer

    遍历与分治的区别：遍历把result作为一个参数进行传递，而分治利用函数本身的返回值；从多线程角度去看，遍历没办法进行多线程操作，而分治可以，分治是把左右子树的结果分别保存到一个数组中，最后再把结果拼接起来，左右子树可以多线程同时去实现递归，不会影响最后的结果。

    分治：分为两个步骤，divide（分），conquer（合）

    前序遍历还是不推荐用分治，但是要体会这个思想，90%二叉树的题目都用到了分治法；

    traverse 并不是通用的，分治更通用；

分治法
- merge sort
- quick sort
- 二叉树

Sort
merge sort：
- 从中间分开，左边递归归并，右边递归归并，使得左边有序，右边有序，然后利用额外空间合并这两个有序数  组，然后再把合并好的数组倒腾到原来的数组里去（耗费很多时间）
- 分治思想，局部有序，最后整体有序；

quick sort
- 做partition，从数组中随机挑选一个数，比它小的放前面，大的放后面；（一般挑选中间的值，挑第一个或者最后一个也可以，只是容易构造它的最后情况）
- 分治思想，先整体有序，然后局部有序

merge sort：O(nlogn)  O(n)  稳定
quick sort：O(nlogn)  O(1)  不稳定

排序中nlogn的堆排序不是分治法，但也利用了这个思想；
实际中快排用的多一点，因为不耗费额外空间，归并排序还要把合并好的新数组放到之前的数组里去，也很耗时间；

稳定性：对于key-value情况，或者排坐标(1,1),(1,2),(1,3)按照x排...

时间复杂度分析：
归并：每次合并两个有序数组耗费的时间是O(n)，然后一半一半的分最后是logn；
     树状结构，每一层合并数组的时间加起来都是O(n),（合并n/2的数组为O(n)...）
快排：是平均复杂度为nlogn
     最好的情况nlogn，平均情况nlogn，最坏的情况n^2；
     最坏：每次partition之后的x都是最小或者最大的数（每次partition时间O(n)），最后要做n次；
     平均是按照概率来算的；
     （在网上看的一个方法，快排之前先把数组打乱一下） 


maximum depth of binary tree    TC:O(n)
balanced binary tree(代码里面定义-1表示不平衡，在实际工程中应该尽量避免这种，最好是给函数返回两个value：depht, isBalanced.)       TC:O(n)

二叉树的时间复杂度基本都是O(n)

binary tree maximum path sum
- sub problem：从根节点出发的最大路径
- 可以从任何节点出发，从任何节点结束，说明要至少包含一个节点；
- 有三种情况，max在左子树，max在柚子树，max跨过root
- maxpath至少包含一个点，singlepath可以不包含点
- 注意一般



一般root为空，退出递归；



概念类：
前中后序遍历
平衡二叉树（优点：在这种树上做插入删除遍历，时间复杂度不会超过logn） 







    
